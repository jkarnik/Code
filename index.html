<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Network Geo-Visualization</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- D3.js for data visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- SheetJS (xlsx.js) for reading Excel files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- Leaflet.js for mapping -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        #tooltip {
            position: absolute; text-align: left; padding: 10px; font-size: 14px;
            background: #2d3748; color: white; border: 1px solid #4a5568;
            border-radius: 8px; pointer-events: none; opacity: 0;
            transition: opacity 0.3s; max-width: 300px; z-index: 1001; /* Above Leaflet */
        }
        .tooltip-key { font-weight: bold; color: #63b3ed; }
        input[type="file"]::file-selector-button {
            background-color: #4a5568; color: white; border: 1px solid #718096;
            padding: 0.5rem 1rem; border-radius: 0.375rem; cursor: pointer;
            transition: background-color 0.2s;
        }
        input[type="file"]::file-selector-button:hover { background-color: #718096; }
        #map-container { background-color: #1a202c; } /* Dark background before map tiles load */
        .leaflet-container { z-index: 1; }
        #overlay-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks to pass through to the map */
            z-index: 1000;
        }
        .app-bubble { /* New style for app circles */
            transition: fill 0.3s ease-in-out;
            stroke: #94a3b8; /* slate-400 */
            stroke-width: 2px;
        }
        .lb-bubble { /* Load balancer circles */
            transition: fill 0.3s ease-in-out;
            stroke: #94a3b8; /* slate-400 */
            stroke-width: 2px;
        }
        .app-label {
            fill: #e2e8f0; /* slate-200 */
            font-weight: bold;
            font-size: 14px;
            text-anchor: middle;
            pointer-events: all; /* Allow hovering on text */
        }
        .connector-path {
            stroke-width: 1.5;
            stroke-opacity: 0.7;
            fill: none;
            transition: stroke 0.3s ease-in-out;
        }
       
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen p-4 sm:p-8">

    <div class="flex h-full">
        <!-- Left Sidebar Controls -->
        <div id="sidebar" class="flex-shrink-0 flex flex-col gap-6" style="width: 320px;">
            <!-- Header -->
            <div>
                <h1 class="text-3xl font-bold text-gray-100 mb-2">Dynamic Network Geo-Topology</h1>
            </div>

            <!-- Controls -->
            <div class="bg-gray-800 p-6 rounded-xl shadow-2xl flex flex-col gap-6">
                <div>
                    <label for="fileInput" class="block text-sm font-medium text-gray-300 mb-2">1. Upload Excel</label>
                    <input type="file" id="fileInput" accept=".xlsx" class="text-sm text-gray-300 file:mr-4 w-full">
                </div>

                <div>
                    <button id="download-sample-btn" class="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-4 rounded-md transition duration-200">
                        Download Sample File
                    </button>
                </div>

                <div class="border-t border-gray-700 pt-4">
                    <div>
                        <label for="size-select" class="block text-sm font-medium text-gray-300 mb-2">2. Bubble Size</label>
                        <select id="size-select" class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" disabled><option>Upload file</option></select>
                    </div>
                </div>

                <div>
                    <label for="color-select" class="block text-sm font-medium text-gray-300 mb-2">3. Bubble Color</label>
                    <select id="color-select" class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" disabled><option>Upload file</option></select>
                </div>

                <div class="border-t border-gray-700 pt-4">
                    <div>
                        <label for="filter-key-select" class="block text-sm font-medium text-gray-300 mb-2">4. Filter Field</label>
                        <select id="filter-key-select" class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" disabled><option value="">Select Field</option></select>
                    </div>
                </div>

                <div>
                    <label for="filter-value-select" class="block text-sm font-medium text-gray-300 mb-2">Filter Value</label>
                    <select id="filter-value-select" class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" disabled><option>Select field first</option></select>
                </div>

                <div>
                    <button id="filter-clear-btn" class="w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-md transition duration-200" disabled>Clear Filter</button>
                </div>
            </div>
        </div>

        <!-- Resize Handle -->
        <div id="resize-handle"></div>

        <!-- Visualization Container -->
        <div class="flex-1 flex flex-col" style="margin-left: 1rem;">
            <div id="vis-wrapper" class="w-full h-full bg-gray-800 rounded-xl shadow-2xl p-2 relative flex flex-col" style="min-height: 80vh;">
                <div id="cloud-area" style="height: 15%;"></div>
                <div id="lb-area" style="height: 20%;"></div>
                <div id="map-container" style="height: 65%;" class="rounded-b-xl"></div>
                <div id="placeholder" class="absolute inset-0 flex items-center justify-center text-gray-500 z-0">
                    <p>Map visualization will appear here...</p>
                </div>
                <svg id="overlay-svg"></svg>
            </div>
        </div>
    </div>

    <!-- Tooltip element -->
    <div id="tooltip"></div>

    <script>
        const fileInput = document.getElementById('fileInput');
        const sizeSelect = document.getElementById('size-select');
        const colorSelect = document.getElementById('color-select');
        const filterKeySelect = document.getElementById('filter-key-select');
        const filterValueSelect = document.getElementById('filter-value-select');
        const filterClearBtn = document.getElementById('filter-clear-btn');
        const downloadSampleBtn = document.getElementById('download-sample-btn');
        const placeholder = document.getElementById('placeholder');
        const tooltip = d3.select("#tooltip");
        const cloudArea = d3.select("#cloud-area");
        const visWrapper = document.getElementById('vis-wrapper');
        const overlaySvg = d3.select("#overlay-svg");
        const sidebar = document.getElementById('sidebar');
        const resizeHandle = document.getElementById('resize-handle');

        let rawData = [], filteredData = [];
        let map, siteSvg, nodeElements;
        let cloudPositions = new Map();
        let lbPositions = new Map();
        let uplinkHealthHeader;
        let connectorColorScale = () => '#64748b';
        let appHealthData = new Map();
        let appLinkHealthData = new Map();

        // Sidebar resize functionality
        let isResizing = false;
        resizeHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
        });

        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;
            const newWidth = e.clientX - sidebar.getBoundingClientRect().left;
            if (newWidth >= 250 && newWidth <= 600) {
                sidebar.style.width = newWidth + 'px';
                if (map) {
                    setTimeout(() => map.invalidateSize(), 0);
                }
            }
        });

        document.addEventListener('mouseup', () => {
            if (isResizing) {
                isResizing = false;
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            }
        });


        // --- EVENT LISTENERS ---
        fileInput.addEventListener('change', handleFile);
        sizeSelect.addEventListener('change', renderVisualization);
        colorSelect.addEventListener('change', renderVisualization);
        filterKeySelect.addEventListener('change', populateFilterValues);
        filterValueSelect.addEventListener('change', applyFilter);
        filterClearBtn.addEventListener('click', clearFilter);
        downloadSampleBtn.addEventListener('click', downloadSampleFile);

        // --- SAMPLE FILE DOWNLOAD ---
        function downloadSampleFile() {
            const sheet1Data = [
                ["", "", "Filter", "Filter", "Size", "Size", "Size", "Color", "Color", "Color", "Color", "Color", "Link Color"],
                ["Site Name", "Lat-Long", "Zone", "App", "Device Count", "Throughput", "Throughput/Device (Avg)", "CPU Ulitlization (Max)", "CPU Ulitlization (Min)", "Memory Usage (Max)", "Memory Usage (Min)", "Device Latency (Max)", "Uplink Health"],
                ["New-Relic-001", "45.1234° N, 102.5678° W", "North", "AWS", 37, 35, 0.9459, 0.9448, 0.2638, 0.5388, 0.1820, 781, 0.9],
                ["New-Relic-002", "33.9876° N, 84.4321° W", "North", "AWS", 30, 4, 0.1333, 0.8209, 0.3447, 0.6874, 0.3277, 2382, 0.85],
                ["New-Relic-033", "1.2345° N, 78.8765° W", "South", "AWS", 17, 27, 1.5882, 0.8267, 0.4525, 0.8817, 0.0034, 1978, 0.92],
                ["New-Relic-078", "0.2345° S, 36.8765° E", "West", "GCP", 41, 78, 1.9024, 0.6772, 0.1533, 0.7212, 0.2314, 2975, 0.3],
                ["New-Relic-088", "59.1234° N, 18.5678° E", "West", "GCP", 15, 79, 5.2666, 0.6917, 0.3152, 0.6933, 0.2356, 410, 0.22],
                ["New-Relic-092", "38.8765° N, 9.4321° W", "West", "Azure", 48, 46, 0.9583, 0.7094, 0.3572, 0.7930, 0.4285, 360, 0.65],
                ["New-Relic-093", "53.5432° N, 6.8765° W", "West", "Azure", 49, 62, 1.2653, 0.9649, 0.4031, 0.8588, 0.2934, 2034, 0.55]
            ];

            const sheet2Data = [
                ["App", "Health"],
                ["AWS", 0.95],
                ["Azure", 0.6],
                ["GCP", 0.25]
            ];

            const ws1 = XLSX.utils.aoa_to_sheet(sheet1Data);
            const ws2 = XLSX.utils.aoa_to_sheet(sheet2Data);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws1, "SiteData");
            XLSX.utils.book_append_sheet(wb, ws2, "AppHealth");
            XLSX.writeFile(wb, "NetworkMap_Sample.xlsx");
        }


        // --- INITIALIZATION ---
        function initMap() {
            if (map) return;
            map = L.map('map-container').setView([20, 0], 2);
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 19
            }).addTo(map);

            L.svg().addTo(map);
            siteSvg = d3.select("#map-container").select("svg").select("g");
        }
        
        // --- DATA PARSING ---
        function parseLatLng(latLngStr) {
            if (typeof latLngStr !== 'string' || !latLngStr.includes(',')) return null;
            try {
                let [lat, lng] = latLngStr.split(',').map(s => s.trim());
                lat = lat.toUpperCase(); lng = lng.toUpperCase();
                let latVal = parseFloat(lat.replace(/[°NWES]/g, ''));
                let lngVal = parseFloat(lng.replace(/[°NWES]/g, ''));
                if (lat.includes('S')) latVal = -latVal;
                if (lng.includes('W')) lngVal = -lngVal;
                if(isNaN(latVal) || isNaN(lngVal)) return null;
                return L.latLng(latVal, lngVal);
            } catch (e) {
                console.error("Could not parse Lat-Long:", latLngStr, e);
                return null;
            }
        }

        function handleFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, { type: 'array' });
                
                // --- Process Sheet 1: Site Data ---
                const firstSheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[firstSheetName];
                const dataAsArray = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: "" });

                if (dataAsArray.length < 3) {
                    placeholder.textContent = 'File format error: Sheet 1 must have 3+ rows.'; return;
                }
                
                const mappingRow = dataAsArray[0];
                const headerRow = dataAsArray[1];
                const dataRows = dataAsArray.slice(2);

                const latLngHeader = headerRow.find(h => h && h.toLowerCase().includes('lat-long'));
                const appHeader = headerRow.find(h => h && h.toLowerCase() === 'app');
                uplinkHealthHeader = headerRow.find(h => h && h.toLowerCase() === 'uplink health');


                if (!latLngHeader || !appHeader) {
                    placeholder.textContent = "Error: Sheet 1 requires 'Lat-Long' and 'App' columns.";
                    return;
                }

                const sizeHeaders = [], colorHeaders = [], filterHeaders = [];
                headerRow.forEach((header, index) => {
                    if (!header) return;
                    const mapping = (mappingRow[index] || '').trim().toLowerCase();
                    if (mapping === 'size') sizeHeaders.push(header);
                    if (mapping === 'color') colorHeaders.push(header);
                    if (mapping === 'filter') filterHeaders.push(header);
                });

                rawData = dataRows.map((row, i) => {
                    const rowObject = { latlng: null, id: `node-${i}` };
                    headerRow.forEach((header, index) => {
                        if (header) {
                             let value = row[index];
                             if(typeof value === 'string') value = value.trim();
                             if (header === latLngHeader) rowObject.latlng = parseLatLng(value);
                             else rowObject[header] = isNaN(value) || value === '' ? value : +value;
                        }
                    });
                    return rowObject;
                }).filter(obj => obj.latlng && obj[appHeader] && Object.keys(obj).length > 2);

                // --- Process Sheet 2: App Health and Link Health (if it exists) ---
                appHealthData.clear();
                appLinkHealthData.clear();
                if (workbook.SheetNames.length > 1) {
                    const secondSheetName = workbook.SheetNames[1];
                    const appHealthWorksheet = workbook.Sheets[secondSheetName];
                    const appHealthAsArray = XLSX.utils.sheet_to_json(appHealthWorksheet, { header: 1, defval: "" });

                    appHealthAsArray.forEach(row => {
                        let appName = row[0];
                        const healthValue = parseFloat(row[1]);
                        const linkHealthValue = parseFloat(row[2]); // Third column for link health
                        if (appName && typeof appName === 'string') {
                            appName = appName.trim();
                        }
                        if (appName && appName.toLowerCase() !== 'row labels' && appName.toLowerCase() !== 'grand total' && appName.toLowerCase() !== 'app') {
                            if (!isNaN(healthValue)) {
                                appHealthData.set(appName, healthValue);
                            }
                            if (!isNaN(linkHealthValue)) {
                                appLinkHealthData.set(appName, linkHealthValue);
                            }
                        }
                    });
                }


                if (rawData.length > 0) {
                    filteredData = [...rawData];
                    placeholder.style.display = 'none';
                    initMap();
                    populateSelectors({ sizeHeaders, colorHeaders, filterHeaders });
                    renderVisualization();
                    
                    const bounds = L.latLngBounds(rawData.map(d => d.latlng));
                    if(bounds.isValid()) map.fitBounds(bounds, {padding: [50, 50]});

                } else {
                    placeholder.style.display = 'flex';
                    placeholder.textContent = 'No valid data with Lat-Long and App found in Sheet 1.';
                }
            };
            reader.readAsArrayBuffer(file);
        }

        // --- UI & FILTER LOGIC ---
        function populateSelectors({ sizeHeaders, colorHeaders, filterHeaders }) {
            sizeSelect.innerHTML = ''; colorSelect.innerHTML = '';
            filterKeySelect.innerHTML = '<option value="">Select Field</option>';
            sizeHeaders.forEach(h => rawData.some(d => typeof d[h] === 'number') && sizeSelect.appendChild(new Option(h, h)));
            colorHeaders.forEach(h => colorSelect.appendChild(new Option(h, h)));
            filterHeaders.forEach(h => filterKeySelect.appendChild(new Option(h, h)));
            [sizeSelect, colorSelect, filterKeySelect, filterClearBtn].forEach(el => el.disabled = false);
            populateFilterValues();
        }

        function populateFilterValues() {
            clearFilter(false);
            const filterKey = filterKeySelect.value;
            const select = filterValueSelect;
            select.innerHTML = '';
            if (!filterKey) {
                select.innerHTML = '<option>Select field first</option>'; select.disabled = true; return;
            }
            const uniqueValues = [...new Set(rawData.map(d => d[filterKey]))].sort((a, b) => (typeof a === 'number' && typeof b === 'number') ? a - b : String(a).localeCompare(String(b)));
            select.innerHTML = '<option value="">-- Select Value --</option>';
            uniqueValues.forEach(v => (v !== null && v !== undefined && v !== '') && select.appendChild(new Option(v, v)));
            select.disabled = false;
        }

        function applyFilter() {
            const filterKey = filterKeySelect.value; const filterValue = filterValueSelect.value;
            filteredData = filterValue ? rawData.filter(d => d[filterKey] == filterValue) : [...rawData];
            renderVisualization();
        }

        function clearFilter(doRender = true) {
            filterValueSelect.selectedIndex = 0;
            if (filteredData.length === rawData.length) return;
            filteredData = [...rawData];
            if (doRender) renderVisualization();
        }

        // --- D3 VISUALIZATION ---
        function renderApps(appColors = new Map()) {
            overlaySvg.selectAll('.app-panel').remove();
            overlaySvg.selectAll('.lb-panel').remove();
            cloudPositions.clear();
            lbPositions.clear();

            const appHeader = Object.keys(rawData[0]).find(h => h.toLowerCase() === 'app');
            const uniqueApps = [...new Set(rawData.map(d => d[appHeader]))];

            const cloudAreaWidth = visWrapper.clientWidth;
            const cloudAreaHeight = visWrapper.clientHeight * 0.15;
            const lbAreaHeight = visWrapper.clientHeight * 0.20;

            const xScale = d3.scalePoint()
                .domain(uniqueApps)
                .range([cloudAreaWidth * 0.15, cloudAreaWidth * 0.85])
                .padding(0.5);

            // Render App Circles (48px radius - 20% smaller than 60px)
            uniqueApps.forEach(app => {
                const g = overlaySvg.append('g').attr('class', 'app-panel');
                const xPos = xScale(app);
                const yPos = cloudAreaHeight / 2;

                g.append('circle')
                    .attr('class', 'app-bubble')
                    .attr('cx', xPos)
                    .attr('cy', yPos)
                    .attr('r', 48)
                    .attr('fill', appColors.get(app) || '#cbd5e1');

                g.append('text')
                    .attr('class', 'app-label')
                    .attr('x', xPos)
                    .attr('y', yPos)
                    .attr('dy', '0.35em')
                    .text(app);

                cloudPositions.set(app, {x: xPos, y: yPos});
            });

            // Render Single Shared Load Balancer (elongated oval in center)
            const lbYOffset = cloudAreaHeight + (lbAreaHeight / 2);
            const lbXCenter = cloudAreaWidth / 2;
            const g = overlaySvg.append('g').attr('class', 'lb-panel');

            g.append('ellipse')
                .attr('class', 'lb-bubble')
                .attr('cx', lbXCenter)
                .attr('cy', lbYOffset)
                .attr('rx', 120) // Horizontal radius
                .attr('ry', 30)  // Vertical radius
                .attr('fill', '#64748b');

            g.append('text')
                .attr('class', 'app-label')
                .attr('x', lbXCenter)
                .attr('y', lbYOffset)
                .attr('dy', '0.35em')
                .attr('font-size', '14px')
                .text('Load Balancer');

            // Store single LB position for connection logic
            lbPositions.set('shared', {x: lbXCenter, y: lbYOffset, rx: 120, ry: 30});
        }
        
        function renderVisualization() {
            if (!filteredData.length || !map) return;
            
            const sizeKey = sizeSelect.value, colorKey = colorSelect.value;
            if (!sizeKey || !colorKey) return;
            
            // Bubble Size Scale
            const sizeDomain = d3.extent(filteredData, d => d[sizeKey] || 0);
            const sizeScale = d3.scaleSqrt().domain(sizeDomain).range([5, 40]);
            
            // Bubble Color Scale
            const colorValues = filteredData.map(d => d[colorKey]);
            const numericColorValues = colorValues.filter(v => typeof v === 'number' && isFinite(v));
            const isNumericColor = numericColorValues.length > 0;

            let colorScale;
            if (isNumericColor) {
                const colorDomain = d3.extent(numericColorValues);
                const interpolator = t => t < 0.5 ? d3.interpolateRgb("green", "yellow")(t * 2) : d3.interpolateRgb("yellow", "red")((t - 0.5) * 2);
                colorScale = d3.scaleSequential(interpolator).domain(colorDomain);
            } else {
                colorScale = d3.scaleOrdinal(d3.schemeTableau10).domain([...new Set(colorValues)]);
            }

            // --- Set App Colors from Sheet 2 data ---
            const appColorsForBubbles = new Map();
            if (appHealthData.size > 0) {
                const appHealthValues = Array.from(appHealthData.values());
                const appHealthDomain = d3.extent(appHealthValues);
                // Higher health is greener
                const interpolator = t => t < 0.5 ? d3.interpolateRgb("red", "yellow")(t * 2) : d3.interpolateRgb("yellow", "green")((t - 0.5) * 2);
                const appHealthColorScale = d3.scaleSequential(interpolator).domain(appHealthDomain);
                
                appHealthData.forEach((health, app) => {
                    appColorsForBubbles.set(app, appHealthColorScale(health));
                });
            }
            renderApps(appColorsForBubbles);


            // Connector Color Scale
            if (uplinkHealthHeader && filteredData.some(d => typeof d[uplinkHealthHeader] === 'number')) {
                const uplinkDomain = d3.extent(filteredData.map(d=>d[uplinkHealthHeader]).filter(v => typeof v === 'number'));
                // Low health = red, mid = yellow, high = green
                const interpolator = t => t < 0.5 ? d3.interpolateRgb("red", "yellow")(t * 2) : d3.interpolateRgb("yellow", "green")((t - 0.5) * 2);
                connectorColorScale = d3.scaleSequential(interpolator).domain(uplinkDomain);
            } else {
                connectorColorScale = () => '#64748b'; // Fallback to default gray
            }
            
            nodeElements = siteSvg.selectAll(".node")
                .data(filteredData, d => d.id)
                .join("g")
                .attr("class", "node cursor-pointer")
                .on("mouseover", handleMouseOver)
                .on("mouseout", handleMouseOut);

            nodeElements.selectAll("circle").remove();
            nodeElements.append("circle")
                .attr("fill", d => {
                    const value = d[colorKey];
                    return (typeof value === 'number' && isFinite(value)) ? colorScale(value) : '#888'; // Default for non-numeric
                })
                .attr("stroke", "#94a3b8")
                .attr("stroke-width", 2)
                .style("opacity", 0.85);
            
            updatePositions();
            map.off("move zoom", updatePositions).on("move zoom", updatePositions);
        }

        function updatePositions() {
            if(!nodeElements) return;
            const currentZoom = map.getZoom();
            const sizeKey = sizeSelect.value;
            const sizeDomain = d3.extent(filteredData, d => d[sizeKey] || 0);
            const sizeScale = d3.scaleSqrt().domain(sizeDomain).range([5, 40]);
            
            // Update site bubbles (uses latLngToLayerPoint because it's inside the leaflet SVG)
            nodeElements.attr("transform", d => {
                const point = map.latLngToLayerPoint(d.latlng);
                return `translate(${point.x},${point.y})`;
            });
            nodeElements.selectAll('circle').attr("r", d => sizeScale(d[sizeKey] || 0) * (currentZoom / 5));
            
            // Update connection paths: site -> shared LB -> apps
            const appHeader = Object.keys(rawData[0]).find(h => h.toLowerCase() === 'app');
            const mapTopOffset = visWrapper.clientHeight * 0.35; // 15% cloud + 20% LB

            // Remove old paths
            overlaySvg.selectAll('.connector-path').remove();
            overlaySvg.selectAll('.lb-to-app-path').remove();

            const sharedLB = lbPositions.get('shared');
            if (!sharedLB) return;

            // Draw paths from site to shared load balancer
            overlaySvg.selectAll('.connector-path')
                .data(filteredData, d => d.id)
                .join('path')
                .attr('class', 'connector-path')
                .attr('stroke', d => {
                    const value = d[uplinkHealthHeader];
                    return (typeof value === 'number' && isFinite(value)) ? connectorColorScale(value) : '#64748b';
                })
                .attr('d', d => {
                    const startPoint = map.latLngToContainerPoint(d.latlng);

                    const x1 = startPoint.x;
                    const y1 = startPoint.y + mapTopOffset;
                    const x2 = sharedLB.x;
                    const y2 = sharedLB.y;

                    // Connect to edge of LB ellipse (bottom edge)
                    const angle = Math.atan2(y1 - y2, x1 - x2);
                    // Use ellipse equation to find intersection point
                    const t = Math.atan2((y1 - y2) / sharedLB.ry, (x1 - x2) / sharedLB.rx);
                    const endX = x2 + sharedLB.rx * Math.cos(t);
                    const endY = y2 + sharedLB.ry * Math.sin(t);

                    const cx = (x1 + endX) / 2;
                    const cy = endY + (y1 > endY ? -40 : 40);

                    return `M${x1},${y1} Q${cx},${cy} ${endX},${endY}`;
                });

            // Create color scale for LB-to-app lines based on Link Health data (column 3)
            let lbToAppColorScale = () => '#94a3b8'; // Default gray
            if (appLinkHealthData.size > 0) {
                const linkHealthValues = Array.from(appLinkHealthData.values());
                const linkHealthDomain = d3.extent(linkHealthValues);
                // Low health = red, mid = yellow, high = green
                const interpolator = t => t < 0.5 ? d3.interpolateRgb("red", "yellow")(t * 2) : d3.interpolateRgb("yellow", "green")((t - 0.5) * 2);
                lbToAppColorScale = d3.scaleSequential(interpolator).domain(linkHealthDomain);
            }

            // Draw paths from shared load balancer to each app (5x thicker = 10px)
            const uniqueApps = [...new Set(filteredData.map(d => d[appHeader]))];
            uniqueApps.forEach(app => {
                const appPos = cloudPositions.get(app);

                if (!appPos) return;

                // Calculate connection points
                const angle = Math.atan2(appPos.y - sharedLB.y, appPos.x - sharedLB.x);

                // Start from edge of LB ellipse (top side)
                const t = Math.atan2((appPos.y - sharedLB.y) / sharedLB.ry, (appPos.x - sharedLB.x) / sharedLB.rx);
                const startX = sharedLB.x + sharedLB.rx * Math.cos(t);
                const startY = sharedLB.y + sharedLB.ry * Math.sin(t);

                // End at bottom of app circle (48px radius)
                const endX = appPos.x - 48 * Math.cos(angle);
                const endY = appPos.y - 48 * Math.sin(angle);

                // Get color from Link Health data (column 3)
                const linkQuality = appLinkHealthData.get(app);
                const lineColor = (linkQuality !== undefined && !isNaN(linkQuality))
                    ? lbToAppColorScale(linkQuality)
                    : '#94a3b8';

                overlaySvg.append('path')
                    .attr('class', 'lb-to-app-path')
                    .attr('stroke', lineColor)
                    .attr('stroke-width', 10)
                    .attr('stroke-opacity', 0.7)
                    .attr('fill', 'none')
                    .attr('d', `M${startX},${startY} L${endX},${endY}`);
            });
        }

        function handleMouseOver(event, d) {
            d3.select(this).select('circle').transition().duration(200).attr("stroke", "#63b3ed").attr("stroke-width", 4);
            tooltip.transition().duration(200).style("opacity", .95);
            let content = '';
            for (const key in d) {
                if (key !== 'latlng' && key !== 'id') {
                     content += `<p><span class="tooltip-key">${key}:</span> ${d[key]}</p>`;
                }
            }
            tooltip.html(content)
                .style("left", (event.pageX + 15) + "px")
                .style("top", (event.pageY - 28) + "px");
        }

        function handleMouseOut() {
            d3.select(this).select('circle').transition().duration(200).attr("stroke", "#94a3b8").attr("stroke-width", 2);
            tooltip.transition().duration(500).style("opacity", 0);
        }
    </script>
</body>
</html>

