<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"> 
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Network Geo-Visualization</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- D3.js for data visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- SheetJS (xlsx.js) for reading Excel files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- Leaflet.js for mapping -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        #tooltip {
            position: absolute; text-align: left; padding: 10px; font-size: 14px;
            background: #2d3748; color: white; border: 1px solid #4a5568;
            border-radius: 8px; pointer-events: none; opacity: 0;
            transition: opacity 0.3s; max-width: 300px; z-index: 1001; /* Above Leaflet */
        }
        .tooltip-key { font-weight: bold; color: #63b3ed; }
        input[type="file"]::file-selector-button {
            background-color: #4a5568; color: white; border: 1px solid #718096;
            padding: 0.5rem 1rem; border-radius: 0.375rem; cursor: pointer;
            transition: background-color 0.2s;
        }
        input[type="file"]::file-selector-button:hover { background-color: #718096; }
        #map-container { background-color: #1a202c; } /* Dark background before map tiles load */
        .leaflet-container { z-index: 1; }
        #overlay-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks to pass through to the map */
            z-index: 1000;
        }
        .app-bubble { /* New style for app circles */
            transition: fill 0.3s ease-in-out;
            stroke: #94a3b8; /* slate-400 */
            stroke-width: 2px;
        }
        .app-label {
            fill: #e2e8f0; /* slate-200 */
            font-weight: bold;
            font-size: 14px;
            text-anchor: middle;
            pointer-events: all; /* Allow hovering on text */
        }
        .connector-path {
            stroke-width: 1.5;
            stroke-opacity: 0.7;
            fill: none;
            transition: stroke 0.3s ease-in-out;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center min-h-screen p-4 sm:p-8">

    <div class="w-full max-w-7xl mx-auto">
        <!-- Header -->
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-100">Dynamic Network Geo-Topology</h1>
            <p class="text-gray-400 mt-2">Upload an Excel file with site data (Sheet 1) and app health (Sheet 2) to visualize your hybrid cloud network.</p>
        </div>

        <!-- Controls -->
        <div class="bg-gray-800 p-4 sm:p-6 rounded-xl shadow-2xl mb-8 flex flex-col sm:flex-row items-end justify-center gap-4 sm:gap-6 flex-wrap">
            <div>
                <label for="fileInput" class="block text-sm font-medium text-gray-300 mb-2">1. Upload Excel</label>
                <input type="file" id="fileInput" accept=".xlsx" class="text-sm text-gray-300 file:mr-4">
            </div>
            <div>
                <label for="size-select" class="block text-sm font-medium text-gray-300 mb-2">2. Bubble Size</label>
                <select id="size-select" class="bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" disabled><option>Upload file</option></select>
            </div>
            <div>
                <label for="color-select" class="block text-sm font-medium text-gray-300 mb-2">3. Bubble Color</label>
                <select id="color-select" class="bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" disabled><option>Upload file</option></select>
            </div>
            <div class="flex items-end gap-2">
                 <div>
                    <label for="filter-key-select" class="block text-sm font-medium text-gray-300 mb-2">4. Filter</label>
                    <select id="filter-key-select" class="bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" disabled><option value="">Select Field</option></select>
                </div>
                <div>
                     <label for="filter-value-select" class="block text-sm font-medium text-gray-300 mb-2 invisible">Value</label>
                    <select id="filter-value-select" class="bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" disabled><option>Select field first</option></select>
                </div>
                <div>
                     <label class="block text-sm font-medium text-gray-300 mb-2 invisible">Action</label>
                    <button id="filter-clear-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-md transition duration-200" disabled>Clear</button>
                </div>
            </div>
        </div>

        <!-- Visualization Container -->
        <div id="vis-wrapper" class="w-full bg-gray-800 rounded-xl shadow-2xl p-2 relative flex flex-col" style="height: 70vh;">
             <div id="cloud-area" class="w-full h-1/4"></div>
             <div id="map-container" class="w-full h-3/4 rounded-b-xl"></div>
             <div id="placeholder" class="absolute inset-0 flex items-center justify-center text-gray-500 z-0">
                <p>Map visualization will appear here...</p>
            </div>
            <svg id="overlay-svg"></svg>
        </div>
    </div>

    <!-- Tooltip element -->
    <div id="tooltip"></div>

    <script>
        const fileInput = document.getElementById('fileInput');
        const sizeSelect = document.getElementById('size-select');
        const colorSelect = document.getElementById('color-select');
        const filterKeySelect = document.getElementById('filter-key-select');
        const filterValueSelect = document.getElementById('filter-value-select');
        const filterClearBtn = document.getElementById('filter-clear-btn');
        const placeholder = document.getElementById('placeholder');
        const tooltip = d3.select("#tooltip");
        const cloudArea = d3.select("#cloud-area");
        const visWrapper = document.getElementById('vis-wrapper');
        const overlaySvg = d3.select("#overlay-svg");

        let rawData = [], filteredData = [];
        let map, siteSvg, nodeElements;
        let cloudPositions = new Map();
        let uplinkHealthHeader;
        let connectorColorScale = () => '#64748b';
        let appHealthData = new Map();


        // --- EVENT LISTENERS ---
        fileInput.addEventListener('change', handleFile);
        sizeSelect.addEventListener('change', renderVisualization);
        colorSelect.addEventListener('change', renderVisualization);
        filterKeySelect.addEventListener('change', populateFilterValues);
        filterValueSelect.addEventListener('change', applyFilter);
        filterClearBtn.addEventListener('click', clearFilter);

        // --- INITIALIZATION ---
        function initMap() {
            if (map) return;
            map = L.map('map-container').setView([20, 0], 2);
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 19
            }).addTo(map);

            L.svg().addTo(map);
            siteSvg = d3.select("#map-container").select("svg").select("g");
        }
        
        // --- DATA PARSING ---
        function parseLatLng(latLngStr) {
            if (typeof latLngStr !== 'string' || !latLngStr.includes(',')) return null;
            try {
                let [lat, lng] = latLngStr.split(',').map(s => s.trim());
                lat = lat.toUpperCase(); lng = lng.toUpperCase();
                let latVal = parseFloat(lat.replace(/[°NWES]/g, ''));
                let lngVal = parseFloat(lng.replace(/[°NWES]/g, ''));
                if (lat.includes('S')) latVal = -latVal;
                if (lng.includes('W')) lngVal = -lngVal;
                if(isNaN(latVal) || isNaN(lngVal)) return null;
                return L.latLng(latVal, lngVal);
            } catch (e) {
                console.error("Could not parse Lat-Long:", latLngStr, e);
                return null;
            }
        }

        function handleFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, { type: 'array' });
                
                // --- Process Sheet 1: Site Data ---
                const firstSheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[firstSheetName];
                const dataAsArray = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: "" });

                if (dataAsArray.length < 3) {
                    placeholder.textContent = 'File format error: Sheet 1 must have 3+ rows.'; return;
                }
                
                const mappingRow = dataAsArray[0];
                const headerRow = dataAsArray[1];
                const dataRows = dataAsArray.slice(2);

                const latLngHeader = headerRow.find(h => h && h.toLowerCase().includes('lat-long'));
                const appHeader = headerRow.find(h => h && h.toLowerCase() === 'app');
                uplinkHealthHeader = headerRow.find(h => h && h.toLowerCase() === 'uplink health');


                if (!latLngHeader || !appHeader) {
                    placeholder.textContent = "Error: Sheet 1 requires 'Lat-Long' and 'App' columns.";
                    return;
                }

                const sizeHeaders = [], colorHeaders = [], filterHeaders = [];
                headerRow.forEach((header, index) => {
                    if (!header) return;
                    const mapping = (mappingRow[index] || '').trim().toLowerCase();
                    if (mapping === 'size') sizeHeaders.push(header);
                    if (mapping === 'color') colorHeaders.push(header);
                    if (mapping === 'filter') filterHeaders.push(header);
                });

                rawData = dataRows.map((row, i) => {
                    const rowObject = { latlng: null, id: `node-${i}` };
                    headerRow.forEach((header, index) => {
                        if (header) {
                             let value = row[index];
                             if(typeof value === 'string') value = value.trim();
                             if (header === latLngHeader) rowObject.latlng = parseLatLng(value);
                             else rowObject[header] = isNaN(value) || value === '' ? value : +value;
                        }
                    });
                    return rowObject;
                }).filter(obj => obj.latlng && obj[appHeader] && Object.keys(obj).length > 2);

                // --- Process Sheet 2: App Health (if it exists) ---
                appHealthData.clear();
                if (workbook.SheetNames.length > 1) {
                    const secondSheetName = workbook.SheetNames[1];
                    const appHealthWorksheet = workbook.Sheets[secondSheetName];
                    const appHealthAsArray = XLSX.utils.sheet_to_json(appHealthWorksheet, { header: 1, defval: "" });
                    
                    appHealthAsArray.forEach(row => {
                        let appName = row[0];
                        const healthValue = parseFloat(row[1]);
                        if (appName && typeof appName === 'string') {
                            appName = appName.trim();
                        }
                        if (appName && appName.toLowerCase() !== 'row labels' && appName.toLowerCase() !== 'grand total' && !isNaN(healthValue)) {
                            appHealthData.set(appName, healthValue);
                        }
                    });
                }


                if (rawData.length > 0) {
                    filteredData = [...rawData];
                    placeholder.style.display = 'none';
                    initMap();
                    populateSelectors({ sizeHeaders, colorHeaders, filterHeaders });
                    renderVisualization();
                    
                    const bounds = L.latLngBounds(rawData.map(d => d.latlng));
                    if(bounds.isValid()) map.fitBounds(bounds, {padding: [50, 50]});

                } else {
                    placeholder.style.display = 'flex';
                    placeholder.textContent = 'No valid data with Lat-Long and App found in Sheet 1.';
                }
            };
            reader.readAsArrayBuffer(file);
        }

        // --- UI & FILTER LOGIC ---
        function populateSelectors({ sizeHeaders, colorHeaders, filterHeaders }) {
            sizeSelect.innerHTML = ''; colorSelect.innerHTML = '';
            filterKeySelect.innerHTML = '<option value="">Select Field</option>';
            sizeHeaders.forEach(h => rawData.some(d => typeof d[h] === 'number') && sizeSelect.appendChild(new Option(h, h)));
            colorHeaders.forEach(h => colorSelect.appendChild(new Option(h, h)));
            filterHeaders.forEach(h => filterKeySelect.appendChild(new Option(h, h)));
            [sizeSelect, colorSelect, filterKeySelect, filterClearBtn].forEach(el => el.disabled = false);
            populateFilterValues();
        }

        function populateFilterValues() {
            clearFilter(false);
            const filterKey = filterKeySelect.value;
            const select = filterValueSelect;
            select.innerHTML = '';
            if (!filterKey) {
                select.innerHTML = '<option>Select field first</option>'; select.disabled = true; return;
            }
            const uniqueValues = [...new Set(rawData.map(d => d[filterKey]))].sort((a, b) => (typeof a === 'number' && typeof b === 'number') ? a - b : String(a).localeCompare(String(b)));
            select.innerHTML = '<option value="">-- Select Value --</option>';
            uniqueValues.forEach(v => (v !== null && v !== undefined && v !== '') && select.appendChild(new Option(v, v)));
            select.disabled = false;
        }

        function applyFilter() {
            const filterKey = filterKeySelect.value; const filterValue = filterValueSelect.value;
            filteredData = filterValue ? rawData.filter(d => d[filterKey] == filterValue) : [...rawData];
            renderVisualization();
        }

        function clearFilter(doRender = true) {
            filterValueSelect.selectedIndex = 0;
            if (filteredData.length === rawData.length) return;
            filteredData = [...rawData];
            if (doRender) renderVisualization();
        }

        // --- D3 VISUALIZATION ---
        function renderApps(appColors = new Map()) {
            overlaySvg.selectAll('.app-panel').remove();
            cloudPositions.clear();

            const appHeader = Object.keys(rawData[0]).find(h => h.toLowerCase() === 'app');
            const uniqueApps = [...new Set(rawData.map(d => d[appHeader]))];

            const cloudAreaWidth = visWrapper.clientWidth;
            const cloudAreaHeight = visWrapper.clientHeight / 4;
            
            const xScale = d3.scalePoint()
                .domain(uniqueApps)
                .range([cloudAreaWidth * 0.15, cloudAreaWidth * 0.85])
                .padding(0.5);

            uniqueApps.forEach(app => {
                const g = overlaySvg.append('g').attr('class', 'app-panel');
                const xPos = xScale(app);
                const yPos = cloudAreaHeight / 2;
                
                // --- MODIFIED: Use a circle instead of a path ---
                g.append('circle')
                    .attr('class', 'app-bubble')
                    .attr('cx', xPos)
                    .attr('cy', yPos)
                    .attr('r', 30)
                    .attr('fill', appColors.get(app) || '#cbd5e1');
                
                g.append('text')
                    .attr('class', 'app-label')
                    .attr('x', xPos)
                    .attr('y', yPos)
                    .attr('dy', '0.35em') // Vertically center text
                    .text(app);
                
                cloudPositions.set(app, {x: xPos, y: yPos});
            });
        }
        
        function renderVisualization() {
            if (!filteredData.length || !map) return;
            
            const sizeKey = sizeSelect.value, colorKey = colorSelect.value;
            if (!sizeKey || !colorKey) return;
            
            // Bubble Size Scale
            const sizeDomain = d3.extent(filteredData, d => d[sizeKey] || 0);
            const sizeScale = d3.scaleSqrt().domain(sizeDomain).range([5, 40]);
            
            // Bubble Color Scale
            const colorValues = filteredData.map(d => d[colorKey]);
            const numericColorValues = colorValues.filter(v => typeof v === 'number' && isFinite(v));
            const isNumericColor = numericColorValues.length > 0;

            let colorScale;
            if (isNumericColor) {
                const colorDomain = d3.extent(numericColorValues);
                const interpolator = t => t < 0.5 ? d3.interpolateRgb("green", "yellow")(t * 2) : d3.interpolateRgb("yellow", "red")((t - 0.5) * 2);
                colorScale = d3.scaleSequential(interpolator).domain(colorDomain);
            } else {
                colorScale = d3.scaleOrdinal(d3.schemeTableau10).domain([...new Set(colorValues)]);
            }

            // --- Set App Colors from Sheet 2 data ---
            const appColorsForBubbles = new Map();
            if (appHealthData.size > 0) {
                const appHealthValues = Array.from(appHealthData.values());
                const appHealthDomain = d3.extent(appHealthValues);
                // Higher health is greener
                const interpolator = t => t < 0.5 ? d3.interpolateRgb("red", "yellow")(t * 2) : d3.interpolateRgb("yellow", "green")((t - 0.5) * 2);
                const appHealthColorScale = d3.scaleSequential(interpolator).domain(appHealthDomain);
                
                appHealthData.forEach((health, app) => {
                    appColorsForBubbles.set(app, appHealthColorScale(health));
                });
            }
            renderApps(appColorsForBubbles);


            // Connector Color Scale
            if (uplinkHealthHeader && filteredData.some(d => typeof d[uplinkHealthHeader] === 'number')) {
                const uplinkDomain = d3.extent(filteredData.map(d=>d[uplinkHealthHeader]).filter(v => typeof v === 'number'));
                // Low health = red, mid = yellow, high = green
                const interpolator = t => t < 0.5 ? d3.interpolateRgb("red", "yellow")(t * 2) : d3.interpolateRgb("yellow", "green")((t - 0.5) * 2);
                connectorColorScale = d3.scaleSequential(interpolator).domain(uplinkDomain);
            } else {
                connectorColorScale = () => '#64748b'; // Fallback to default gray
            }
            
            nodeElements = siteSvg.selectAll(".node")
                .data(filteredData, d => d.id)
                .join("g")
                .attr("class", "node cursor-pointer")
                .on("mouseover", handleMouseOver)
                .on("mouseout", handleMouseOut);

            nodeElements.selectAll("circle").remove();
            nodeElements.append("circle")
                .attr("fill", d => {
                    const value = d[colorKey];
                    return (typeof value === 'number' && isFinite(value)) ? colorScale(value) : '#888'; // Default for non-numeric
                })
                .attr("stroke", "#94a3b8")
                .attr("stroke-width", 2)
                .style("opacity", 0.85);
            
            updatePositions();
            map.off("move zoom", updatePositions).on("move zoom", updatePositions);
        }

        function updatePositions() {
            if(!nodeElements) return;
            const currentZoom = map.getZoom();
            const sizeKey = sizeSelect.value;
            const sizeDomain = d3.extent(filteredData, d => d[sizeKey] || 0);
            const sizeScale = d3.scaleSqrt().domain(sizeDomain).range([5, 40]);
            
            // Update site bubbles (uses latLngToLayerPoint because it's inside the leaflet SVG)
            nodeElements.attr("transform", d => {
                const point = map.latLngToLayerPoint(d.latlng);
                return `translate(${point.x},${point.y})`;
            });
            nodeElements.selectAll('circle').attr("r", d => sizeScale(d[sizeKey] || 0) * (currentZoom / 5));
            
            // Update splines
            const appHeader = Object.keys(rawData[0]).find(h => h.toLowerCase() === 'app');
            const mapTopOffset = visWrapper.clientHeight / 4;

            overlaySvg.selectAll('.connector-path')
                .data(filteredData, d => d.id)
                .join('path')
                .attr('class', 'connector-path')
                .attr('stroke', d => {
                    const value = d[uplinkHealthHeader];
                    return (typeof value === 'number' && isFinite(value)) ? connectorColorScale(value) : '#64748b';
                })
                .attr('d', d => {
                    const startPoint = map.latLngToContainerPoint(d.latlng);
                    const endCloud = cloudPositions.get(d[appHeader]);

                    if(!endCloud) return "";

                    // startPoint is relative to map-container, so add mapTopOffset for the y-coordinate
                    const x1 = startPoint.x;
                    const y1 = startPoint.y + mapTopOffset;
                    const x2 = endCloud.x;
                    const y2 = endCloud.y;

                    // Adjust spline to connect to the edge of the circle
                    const angle = Math.atan2(y1 - y2, x1 - x2);
                    const radius = 30; // Radius of the app bubble
                    const endX = x2 + radius * Math.cos(angle);
                    const endY = y2 + radius * Math.sin(angle);


                    const cx = (x1 + endX) / 2;
                    const cy = endY + (y1 > endY ? -40 : 40);

                    return `M${x1},${y1} Q${cx},${cy} ${endX},${endY}`;
                });
        }

        function handleMouseOver(event, d) {
            d3.select(this).select('circle').transition().duration(200).attr("stroke", "#63b3ed").attr("stroke-width", 4);
            tooltip.transition().duration(200).style("opacity", .95);
            let content = '';
            for (const key in d) {
                if (key !== 'latlng' && key !== 'id') {
                     content += `<p><span class="tooltip-key">${key}:</span> ${d[key]}</p>`;
                }
            }
            tooltip.html(content)
                .style("left", (event.pageX + 15) + "px")
                .style("top", (event.pageY - 28) + "px");
        }

        function handleMouseOut() {
            d3.select(this).select('circle').transition().duration(200).attr("stroke", "#94a3b8").attr("stroke-width", 2);
            tooltip.transition().duration(500).style("opacity", 0);
        }
    </script>
</body>
</html>

